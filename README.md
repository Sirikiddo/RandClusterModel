# Желаемая архитектурная схема Planet Engine

## 1. UI (источник ввода)

* Получает действия пользователя.
* Генерирует команды: изменение параметров, выбор объектов, нажатия кнопок.
* Не изменяет сцену напрямую и не запускает вычислений.

```
[ПОЛЬЗОВАТЕЛЬ] → [UI] → команды в PlanetCore
```

## 2. Синхронная граница №1 — фиксация состояния

**PlanetCore::applyInput()**

* Применяет команды UI к внутренним настройкам.
* Увеличивает `sceneVersion`.
* Создаёт неизменяемый снимок сцены/модели.
* Готовит параметры для асинхронных вычислительных задач.
* Запускает асинхронные задачи.

## 3. Async/Parallel слой логики

**AsyncComputeLayer**

* Работает только на копиях (снимках) данных.
* Выполняет тяжёлые вычисления:

  * Генерация мешей
  * Карты высот, шумы, нормали
  * Сглаживание, фильтры
  * Поиск путей
  * Опциональные GPU compute-задачи
* Внутри задач может использовать parallel_for.
* Не имеет доступа к renderer, ECS или изменяемой сцене.
* Возвращает `(result, version)` обратно в PlanetCore.

## 4. Синхронная граница №2 — merge

**PlanetCore::commitAsyncResult()**

* Выполняется в главном потоке.
* Проверяет версию: принимает результат только если версия совпадает с текущей.
* Обновляет данные сцены.
* Формирует RenderGraph.
* Готовит данные для рендера.

## 5. Синхронный слой рендера

**Renderer**

* Использует RenderGraph.
* Обновляет GPU-ресурсы (VBO/IBO/UBO).
* Выполняет команды рисования OpenGL.
* Полностью синхронный.

## Глобальная схема потоков

```
[UI] → applyInput() → async/parallel compute → commitAsyncResult() → render()

          ┌─────────────────────────┐
          │   1. СИНХРОННЫЙ ВВОД    │
          │ UI → applyInput()       │
          └────────────┬────────────┘
                       │ ГРАНИЦА №1
                       ▼
          ┌─────────────────────────┐
          │ 2. ASYNC/PARALLEL ЛОГИКА │
          │ compute(snapshot)       │
          └────────────┬────────────┘
                       │ ГРАНИЦА №2
                       ▼
          ┌─────────────────────────┐
          │    3. СИНХРОННЫЙ РЕНДЕР │
          │ commit → buildGraph → draw │
          └─────────────────────────┘
```

## Архитектурные гарантии

* UI никогда напрямую не изменяет состояние ядра.
* Асинхронные задачи не могут повредить сцену или вызвать гонки.
* Только синхронный merge обновляет состояние мира.
* Renderer всегда получает согласованные, проверенные данные.

## Преимущества

* Чёткое разделение ответственности.
* Детерминированный рендер.
* Безопасное асинхронное и параллельное ускорение.
* Масштабируемый слой логики.
* Предсказуемый процесс для разработчиков.
