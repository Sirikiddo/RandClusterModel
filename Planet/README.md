# Архитектура проекта Planet (как ориентироваться в коде)

Этот документ объясняет, **как устроен проект Planet** и **куда смотреть для любой доработки**. Он построен в три уровня ведения за руку:

1. **Минимальный минимум** — что за игра, кто главные участники, как течёт управление.
2. **Основное понимание** — подробные слои, потоки данных, игровой цикл.
3. **Специализированные разделы** — куда лезть для конкретных задач (шейдеры, picking, ECS и т.п.).

Если вы только открыли репозиторий, начните с уровней 0–1, затем переходите к уровню 2. Уровень 3 можно читать по мере необходимости.

---

## Уровень 0. О проекте в 30 секунд

Planet — это интерактивная модель сферической планеты на Qt + OpenGL.

Главный поток:

```text
Qt-события → Qt-виджет (HexSphereWidget)
            → InputController (логика)
            → HexSphereSceneController + ECS (данные)
            → HexSphereRenderer (OpenGL)
            → картинка на экране
```

Три ключевые роли:

* **UI (Qt-виджеты)** — принимают события, рисуют обвязку интерфейса.
* **Контроллеры** — решают, как изменится состояние планеты и сущностей.
* **Renderer** — только рисует то, что подготовила логика.

---

## Уровень 1. Минимальный минимум

Цель: дать простую ментальную модель, чтобы стало ясно, **кто с кем разговаривает** и в каком порядке.

### 1. Главная идея архитектуры

Архитектура разделена на слои:

* UI (`ui/`) — окна, панель настроек, OpenGL-виджет.
* Контроллеры (`controllers/`) — принимают события, меняют состояние модели, вызывают рендер.
* Модель и генерация (`model/`, `generation/`) — чистые структуры данных и алгоритмы генерации рельефа.
* ECS (`ECS/`) — сущности и компоненты (юниты, маркеры и т.д.).
* Renderer (`renderers/`) — связывает всё с OpenGL и шейдерами.

**Главный принцип:** события идут сверху вниз (от UI к логике и данным), а отрисовка снизу вверх (от данных к GPU).

---

### 2. Центральная дорожка данных (самый важный путь)

Самый частый путь, который проходит событие в системе:

```text
Событие Qt (мышь, клавиатура, колесо)
   ↓
HexSphereWidget (QOpenGLWidget)
   ↓
InputController (логика ввода и сцены)
   ↓
HexSphereSceneController (логика планеты) / ECS (юниты и объекты) / Model (сырые данные) 
   ↓
HexSphereRenderer → OpenGL → GPU (шейдеры)
   ↓
кадр на экране
```

В ещё более сжатом виде это можно свести к цепочке:

```text
UI → Controller → Scene/ECS → Renderer → GPU → экран
```

Эту схему полезно держать в голове при чтении кода.

Для наглядности общую связку основных классов можно представить так:

```text
HexSphereWidget
   ├─ CameraController
   └─ InputController
            ├─ HexSphereSceneController
            ├─ ECS::ComponentStorage
            └─ HexSphereRenderer
```

---

### 3. Три файла, с которых стоит начать

Если вы впервые открыли проект, начните с этих трёх мест:

1. `ui/HexSphereWidget.*` — мост между Qt и логикой:

   * принимает события Qt;
   * владеет OpenGL-контекстом;
   * делегирует всё в `InputController`.
2. `controllers/InputController.*` — главный контроллер:

   * обрабатывает ввод;
   * управляет сценой планеты и ECS;
   * вызывает рендер.
3. `controllers/HexSphereSceneController.*` — логика планеты:

   * хранит и перестраивает модель планеты (`HexSphereModel`);
   * управляет высотами, биомами, выделением и путями.

Отдельно важен `controllers/CameraController.*` — контроллер камеры, который задаёт матрицы `view`/`projection` и направление луча под курсором. Он используется почти во всех этапах рендера.

Поняв, как связаны эти три файла и камера, вы поймёте всё остальное.

---

### 4. Минимальный сценарий запуска

Упрощённая цепочка от запуска до первой отрисовки:

```text
core/main.cpp
  → MainWindow
    → HexSphereWidget
      → initializeGL
        → InputController::initialize
          → HexSphereRenderer::initialize
          → HexSphereSceneController::rebuildModel
          → ECS::createEntity("Explorer")
      → paintGL
        → InputController::render
          → HexSphereRenderer::renderScene
```

То есть:

1. `core/main.cpp` создаёт `QApplication` и `MainWindow`.
2. `MainWindow` создаёт `HexSphereWidget` и панель настроек.
3. При первой отрисовке `HexSphereWidget::initializeGL()` вызывает `InputController::initialize`:

   * запрашиваются функции OpenGL;
   * инициализируется `HexSphereRenderer`;
   * создаются базовые ECS-сущности;
   * перестраивается модель планеты и загружаются буферы.
4. Затем Qt вызывает `paintGL()` → `InputController::render()` → `HexSphereRenderer::renderScene()`.

---

### 5. Минимальный пример: что происходит при клике мышью по ячейке

1. Qt вызывает `HexSphereWidget::mousePressEvent(QMouseEvent* e)`.
2. `HexSphereWidget` передаёт событие в контроллер:

   ```cpp
   auto response = inputController_->mousePress(e);
   ```
3. В `InputController::mousePress`:

   * берётся позиция курсора `e->position()`;
   * вызывается `pickSceneAt(...)`, чтобы понять, в какую ячейку или сущность попал луч;
   * если попали в ячейку:

     * обновляется выделение в `HexSphereSceneController` (`scene_.toggleCellSelection(...)`);
     * по возможности двигается выбранная сущность в эту ячейку (через ECS);
     * при необходимости вызываются `uploadSelection()` / `rebuildModel()`;
     * ставится флаг `response.requestUpdate = true`.
4. `HexSphereWidget` по флагу вызывает `update()`.
5. Qt вызывает `paintGL()`, который вызывает `InputController::render()`.
6. В `render()` формируются структуры `RenderGraph`, `RenderCamera`, `SceneLighting` и вызывается `renderer_->renderScene(...)`, после чего на экране видна новая конфигурация планеты и объектов.

После этого можно переходить к более детальному уровню.

---

## Сборка и запуск

Проект собирается под **Windows**, с использованием **Qt 6.8+**, компилятора **MSVC 2022**, и OpenGL **Core Profile 3.3**. Эти параметры — договорённость проекта и гарантируют корректную работу всех зависимостей.

Чтобы собрать Planet:

1. Установите Qt 6.8+ (комплект **msvc2022_64**) с модулями **Qt Widgets** и **Qt OpenGL**.
2. Откройте проект в Qt Creator (комплект MSVC 2022) или соберите через CMake (если используется CMakeLists.txt).
3. Убедитесь, что включена сборка ресурса `Planet.qrc`.
4. Соберите проект (Debug/Release).
5. Запустите бинарный файл.

---

## Уровень 2. Основное понимание архитектуры

Здесь описано, **из чего состоит проект**, как устроены слои и как течёт управление внутри кадра.

### 6. Архитектурные принципы (что делать и чего не делать)

Чтобы код оставался понятным и расширяемым, проект придерживается простых правил:

* UI (`ui/`) **не содержит игровой логики**. Виджеты принимают события и вызывают контроллеры.
* Контроллеры (`controllers/`) **ничего не рисуют сами** и используют Qt только как источник событий (`QMouseEvent`, `QWheelEvent`, `QKeyEvent`) и как способ доступа к виджету (`QOpenGLWidget*`). Они не зависят от UI-компонентов Qt и не содержат разметки интерфейса.
* Модель и генерация (`model/`, `generation/`) — **чистый C++ без Qt и OpenGL**: структуры данных и функции.
* Рендереры (`renderers/`) работают только с:

  * данными от контроллеров,
  * OpenGL и шейдерами,
  * и **не меняют** игровое состояние.
* ECS (Entity Component System, `ECS/`) хранит сущности и компоненты, но **не знает**, как их рисуют и кто ими управляет.

Что важно *не* делать:

* Не тянуть OpenGL в `controllers/` и `model/`.
* Не менять состояние планеты внутри рендереров.
* Не вшивать игровую логику внутрь UI-виджетов.

Если при добавлении фичи эти правила нарушаются — архитектуру стоит пересмотреть.

---

### 7. Слои и модули проекта

#### 7.1. UI (главное окно и виджеты)

* `core/main.cpp`

  * создаёт `QApplication`;
  * настраивает формат OpenGL;
  * создаёт и показывает `MainWindow`.

* `ui/MainWindow.*`

  * создаёт центральный OpenGL-виджет `HexSphereWidget`;
  * создаёт панель настроек `PlanetSettingsPanel` в доке;
  * соединяет сигналы панели (изменение генератора, параметров рельефа и т.п.) с методами центрального виджета.

* `ui/PlanetSettingsPanel.*`

  * отвечает за элементы управления параметрами планеты и генерации.

* `ui/HexSphereWidget.*`

  * наследник `QOpenGLWidget`;
  * отвечает за `initializeGL`, `resizeGL`, `paintGL`;
  * принимает Qt-события (`mouse*`, `key*`, `wheel`) и передаёт их в контроллер;
  * хранит:

    * `CameraController` — управление камерой;
    * `InputController` — логика ввода, сцены и рендера.

**HexSphereWidget не:**

* не содержит логики генерации планеты;
* не управляет напрямую ECS и рендерером — передаёт это в контроллеры.

---

#### 7.2. Контроллеры (логика)

##### 7.2.1. InputController — главный контроллер

* Файлы: `controllers/InputController.*`.
* Центральное место, где сходится всё:

  * инициализирует `HexSphereRenderer` и OpenGL-функции;
  * создаёт начальные сущности (например, «исследователь» на поверхности);
  * хранит:

    * `HexSphereSceneController` — состояние планеты и её меши;
    * `ecs::ComponentStorage` — сущности и компоненты (позиция, коллайдеры, меши);
    * `PerformanceStats` — статистика рендеринга;
    * настройки загрузки буферов.
* Обрабатывает ввод:

  * клики мышью, перемещение, колесо, клавиши;
  * вычисляет луч от камеры под курсором;
  * выбирает ячейки планеты и сущности;
  * меняет высоту, биомы, выделение, путь;
  * двигает выбранную сущность по поверхности.
* Управляет перестройкой сцены:

  * `rebuildModel()` — пересобирает модель планеты при изменении параметров генерации, уровня разбиения, ручном изменении высот или биомов (через методы `setSubdivisionLevel`, `regenerateTerrain`, изменение параметров сглаживания и т.п.);
  * `uploadBuffers()` — отправляет данные на GPU;
  * `render()` — собирает `RenderGraph` (структуру данных для кадра), `RenderCamera` (матрицы камеры), `SceneLighting` (параметры освещения кадра) и вызывает `HexSphereRenderer`.

**InputController не:**

* не вызывает напрямую OpenGL-функции (делегирует рендереру);
* не содержит UI-логики и разметки;
* не изменяет данные планеты минуя `HexSphereSceneController`.

##### 7.2.2. CameraController — камера

* Файлы: `controllers/CameraController.*`.
* Отвечает за:

  * положение и ориентацию камеры;
  * матрицы `view` и `projection`;
  * вращение (`rotate`), зум (`zoom`), сброс (`reset`);
  * вычисление направления луча по экранным координатам (`rayDirectionFromScreen`).

##### 7.2.3. HexSphereSceneController — контроллер планеты

* Файлы: `controllers/HexSphereSceneController.*`.
* Отвечает за:

  * уровень разбиения (subdivision level);
  * модель планеты (`HexSphereModel`);
  * параметры генерации рельефа и биомов;
  * CPU-меши террейна, воды, контура выделения, пути;
  * список выделенных ячеек.
* Предоставляет методы:

  * смена генератора рельефа;
  * перерасчёт рельефа;
  * построение полигона пути по выделенным ячейкам;
  * построение данных для рендера (позиции, индексы, владельцы треугольников и т.п.).

**HexSphereSceneController не:**

* не знает про Qt и OpenGL;
* не рисует ничего сам — только готовит данные.

---

#### 7.3. Данные и генерация

* Папка: `model/`

  * `HexSphereModel` — данные ячеек (центры, соседи, высоты, биомы).

* Папка: `generation/`

  * интерфейс генераторов рельефа;
  * конкретные генераторы (плоский, синус, Перлин, климатический и др.);
  * генераторы мешей террейна, воды, wire-каркаса, контура выделения.

Это чистые структуры и функции C++, независимые от Qt и OpenGL.

##### 7.3.1. Мини-структура данных планеты

В упрощённом виде основные структуры данных выглядят так:

* **Cell** (ячейка планеты, элемент `HexSphereModel`):

  * `id` — индекс ячейки;
  * `centroid` — центр ячейки на сфере (в мировых координатах);
  * `neighbors` — список соседних ячеек по ребру;
  * `height` — относительная высота (используется при генерации террейна);
  * `biome` — тип биома (море, трава, снег и т.п.).
* **Terrain mesh** (CPU-меш поверхности):

  * `pos[]` — массив вершин (x, y, z);
  * `idx[]` — индексы треугольников;
  * `triOwner[]` — для каждого треугольника — индекс ячейки `Cell`, которой он принадлежит (используется для picking).

Таким образом, `HexSphereModel` описывает топологию и параметры ячеек, а производные структуры в `scene/` и `generation/` строятся на его основе и передаются в рендерер.

##### 7.3.2. Пайплайн генерации мешей

Упрощённо, путь от модели до рендера таков:

1. `HexSphereSceneController` хранит `HexSphereModel` и параметры генерации.
2. При изменении параметров (генератор, уровень разбиения, сглаживание) вызывается `rebuildModel()`.
3. Внутри `rebuildModel()` используются функции из `generation/`:

   * генераторы рельефа обновляют высоты и биомы ячеек в `HexSphereModel`;
   * генераторы мешей строят CPU-меши террейна, воды, wire-каркаса, контура выделения.
4. `InputController::uploadBuffers()` передаёт полученные массивы вершин и индексов в `HexSphereRenderer::uploadScene(...)`.
5. `HexSphereRenderer` создаёт/обновляет VBO/IBO и далее использует их в `renderScene(...)`.

Это можно представить в виде краткой схемы:

```text
HexSphereModel
   ↓ (генераторы рельефа)
обновлённые высоты/биомы
   ↓ (MeshGenerators)
TerrainMesh / WaterGeometry / Wire / Outline / Path
   ↓ (uploadScene)
GPU-буферы (VBO/IBO)
   ↓ (renderScene)
кадр на экране
```

`model/` отвечает за топологию и параметры ячеек, `generation/` — за превращение этих данных в геометрию для рендера.

#### 7.4. Рендеринг (визуализация)

* Папка: `renderers/`.
* `HexSphereRenderer`:

  * владеет шейдерами и OpenGL-буферами (VBO/IBO, VAO);
  * имеет методы:

    * `initialize(...)` — создание ресурсов;
    * `uploadScene(...)` — загрузка планеты;
    * `uploadSelectionOutline(...)` — контур выделения;
    * `uploadPath(...)` — путь по поверхности;
    * `renderScene(...)` — отрисовка кадра.
* Под-рендереры (terrain, water, entities, overlay) рисуют соответствующие части сцены.

  * TerrainRenderer — рендерит поверхность планеты на основе террейн-меша.
  * WaterRenderer — рендерит воду и эффект анимации по `waterTime_`.
  * EntityRenderer — рисует сущности из ECS (по их `Mesh` и `Transform`).
  * OverlayRenderer — рисует контуры выделения, путь и вспомогательную графику.

Внутри рендера буферы настраиваются как STATIC или DYNAMIC в зависимости от стратегии загрузки (`UploadOptions`), выбираемой `InputController` (например, при высоком уровне разбиения используются динамические буферы).

**Рендереры не:**

* не меняют состояние `HexSphereSceneController` и `ECS`;
* не принимают решения геймплея — только рисуют данные, которые получили.

---

#### 7.5. ECS и scene helpers

В проекте есть две разные «семьи» сущностей — это важно понимать, чтобы не запутаться:

1. **ECS-сущности** (`ecs::Entity` из `ECS/Entity.h`)

   * живут в `ECS::ComponentStorage`;
   * состоят из набора компонентов (`Transform`, `Mesh`, `Collider`, `Material`, `Script` и др.);
   * используются для геймплейных объектов: юнитов, маркеров, «исследователя», будущих башен и т.п.;
   * создаются и управляются в `InputController`.

2. **Сценовые сущности/узлы** (`scene::Entity` и связанные типы из `scene/`)

   * описывают граф сцены и вспомогательные геометрические структуры (узлы, связи, трансформации);
   * помогают работать с CPU-представлением сцены (иерархии, локальные системы координат, вспомогательные геометрические объекты);
   * не являются частью ECS и не используются напрямую рендерером для геймплейных объектов.

Разделение простое:

* всё, что связано с **игровыми объектами** и их поведением, — в `ECS/`;

* всё, что связано с **геометрической структурой сцены** (поверхность, контуры, вспомогательные узлы), — в `scene/`.

* Папка: `ECS/`

  * `ComponentStorage` — хранение сущностей и наборов компонентов:

    * `Transform` — позиция в мире;
    * `Mesh` — какой меш рисовать;
    * `Collider` — сфера для пика/столкновений;
    * другие компоненты по мере необходимости.
  * `InputController` создаёт сущности и управляет их жизненным циклом.

* Папка: `scene/`

  * вспомогательные структуры, связанные с CPU-представлением сцены:

    * данные для выделения, навигации, пути (например, полигоны выделения и линии маршрутов по ячейкам);
    * вспомогательные геометрические структуры для построения террейна и контура.
  * Это **не ECS-сцена**, а логический контейнер данных поверхности, работающий вместе с `HexSphereModel`.

Грубо говоря, `model/` описывает «чистую» топологию планеты (ячейки и их свойства), `scene/` — производные структуры для отображения и интерактивных операций (выделение, пути, контуры), а `ECS/` — геймплейные объекты, которые «живут» на этой поверхности.

---

#### 7.6. Ресурсы, документация, инструменты

* `resources/` — Qt-ресурсы, шейдеры и другие данные (`Planet.qrc`).
* `docs/` — заметки по архитектуре и плану рефакторинга (например, `planet_reorg_tasks.md`).
* `tools/` — утилиты для отладки и генерации данных.
* `tests/` — тесты и экспериментальные сцены (минимальные примеры использования).

---

#### 7.7. Таблица зависимостей слоёв

| Модуль/слой                | Получает данные от          | Зависит на                                                                 |
| -------------------------- | --------------------------- | -------------------------------------------------------------------------- |
| `core/main.cpp`            | —                           | Qt, `MainWindow`                                                           |
| `MainWindow`               | Qt                          | `HexSphereWidget`, `PlanetSettingsPanel`                                   |
| `PlanetSettingsPanel`      | —                           | Qt Widgets                                                                 |
| `HexSphereWidget`          | Qt (события)                | `InputController`, `CameraController`                                      |
| `CameraController`         | `HexSphereWidget` (размеры) | математика, без Qt/UI                                                      |
| `InputController`          | `HexSphereWidget`, Panel    | `HexSphereSceneController`, `ECS`, `HexSphereRenderer`, `CameraController` |
| `HexSphereSceneController` | `InputController`           | `HexSphereModel`, `generation`                                             |
| `HexSphereRenderer`        | `InputController`           | OpenGL, ресурсы/шейдеры                                                    |
| `HexSphereModel`           | `HexSphereSceneController`  | —                                                                          |
| `generation/*`             | `HexSphereSceneController`  | —                                                                          |
| `scene/`                   | `HexSphereSceneController`  | `HexSphereModel`                                                           |
| `ECS`                      | `InputController`           | —                                                                          |

---

### 8. Поток работы приложения (расширенно)

Эта глава развивает минимальный сценарий из раздела 4 и описывает те же шаги более подробно, с привязкой к конкретным классам и файлам.

1. **Запуск приложения**

   * `core/main.cpp` создаёт `QApplication`, настраивает формат OpenGL, создаёт и показывает `MainWindow`.

2. **Создание UI**

   * `MainWindow` создаёт `HexSphereWidget` и `PlanetSettingsPanel`, соединяет сигналы панели с методами виджета.

3. **Инициализация OpenGL и сцены**

   * Qt вызывает `HexSphereWidget::initializeGL()`;
   * внутри вызывается `InputController::initialize(owner)`:

     * запрашиваются функции OpenGL;
     * инициализируется `HexSphereRenderer`;
     * создаются начальные ECS-сущности;
     * вызывается `rebuildModel()` и загрузка буферов.

4. **Работа приложения**

   * События UI (мышь/клавиатура/панель) доходят до `HexSphereWidget` и `MainWindow` и через них в контроллеры.
   * Контроллеры меняют состояние модели и ECS.
   * При необходимости вызывается `update()` → `paintGL()` → `render()`.

---

### 9. Игровой цикл и время жизни кадра

Игровой цикл реализован простым способом на стороне Qt:

1. В `HexSphereWidget` настроен таймер, который периодически:

   * вызывает `InputController::advanceWaterTime(dt)`;
   * вызывает `update()`, чтобы перерисовать сцену.

2. Qt вызывает `HexSphereWidget::paintGL()`.

3. `HexSphereWidget` вызывает `InputController::render()`.

4. В `render()`:

   * формируется `RenderGraph` из текущей сцены (`HexSphereSceneController`, `ECS` и др.);
   * формируется `RenderCamera` из `CameraController`;
   * формируется `SceneLighting` (направление света, `waterTime_` и т.п.).

5. Эти структуры передаются в `HexSphereRenderer::renderScene(...)`.

6. `HexSphereRenderer` вызывает под-рендереры (terrain, water, entities, overlay) и выдаёт команды OpenGL.

7. `PerformanceStats` обновляет статистику кадра (FPS, счётчики вызовов).

Этот цикл повторяется каждый раз при перерисовке (по таймеру или в ответ на события).

#### 9.1. Время жизни кадра (границы кадра)

Условно один кадр проходит такие стадии:

1. **Начало кадра** — Qt вызывает `HexSphereWidget::paintGL()`. С этого момента начинается формирование нового изображения.
2. **Подготовка данных** — внутри `paintGL()` вызывается `InputController::render()`, где создаются `RenderGraph`, `RenderCamera`, `SceneLighting` и другие структуры для текущего состояния сцены.
3. **Команды рендеринга** — `HexSphereRenderer::renderScene(...)` очищает буферы, настраивает состояния OpenGL и вызывает под-рендереры (terrain, water, entities, overlay).
4. **Отображение на экране** — Qt/`QOpenGLWidget` выполняет обмен буферов (swap buffers), и готовый кадр попадает на экран.

После этого цикл повторяется при следующем вызове `paintGL()`.

#### 9.2. Основные допущения движка

В текущей версии движка используются несколько упрощающих предположений:

* планета — единичная сфера (радиус 1) в мировых координатах;
* все позиции ячеек и сущностей задаются в декартовых координатах на этой сфере;
* размер планеты и её форма не меняются во времени;
* не используется LOD: при увеличении уровня разбиения растёт фактическое число треугольников;
* игровая логика исходит из того, что поверхность связная и без «дыр».

Эти допущения важны при планировании сложных фич (масштабирование планеты, несколько планет, локальные патчи с другим разрешением и т.п.).

---

## Уровень 3. Специализированные разделы

Эти разделы нужны не всем сразу. Сюда имеет смысл идти, когда вы уже понимаете общий поток и хотите добавить конкретную фичу.

### 10. Типичные задачи и куда смотреть

Несколько типичных сценариев и точек входа в код. Этот раздел стоит прочитать сразу после уровней 0–2: он даёт быстрый «how-to» по частым действиям.

* **Добавить новый тип сущности (юнит, маркер и т.п.)**

  * Создать нужные компоненты в `ECS/` (если их ещё нет).
  * В `InputController::initialize` или отдельном методе создать сущность через `ecs_.createEntity(...)` и навесить компоненты (`Transform`, `Mesh`, `Collider`, `Script` и т.п.).

* **Добавить новый параметр/кнопку в UI**

  * Добавить виджеты в `ui/PlanetSettingsPanel.*`.
  * Прокинуть сигнал в `MainWindow`, оттуда — в методы `HexSphereWidget` / `InputController`.

* **Изменить генерацию рельефа**

  * Посмотреть существующие генераторы в `generation/`.
  * Добавить новый класс-генератор и зарегистрировать его в `HexSphereSceneController::setGeneratorByIndex`.

* **Изменить визуальный стиль воды или террейна**

  * Найти соответствующий под-рендерер в `renderers/` (`TerrainRenderer`, `WaterRenderer`).
  * Открыть связанные шейдеры из `resources/` и изменить параметры/формулы.

* **Добавить новый компонент в ECS**

  * Создать структуру компонента в `ECS/`.
  * Зарегистрировать его в `ComponentStorage::mapFor<...>`.
  * Использовать компонент при создании сущностей и в системах, которые его обрабатывают.

* **Добавить/изменить логику пути между двумя ячейками**

  * Смотреть `controllers/PathBuilder.*` и вызов `HexSphereSceneController::buildPathPolyline()`.
  * Там же можно поменять метрику/эвристику A* или форму полилинии.

---

### 11. Где искать код для изменений (подробная карта)

Для любой новой фичи можно пользоваться следующей картой, если коротких подсказок из раздела 10 недостаточно:

* **Поведение при клике, движении мыши, нажатии клавиш**

  * `ui/HexSphereWidget.*` — вход Qt-событий;
  * `controllers/InputController.*` — логика реакции и изменения состояния.

* **Управление камерой (вращение, зум, FOV, луч под курсор)**

  * `controllers/CameraController.*`.

* **Логика планеты (сеточка, высоты, биомы, выделение, путь)**

  * `controllers/HexSphereSceneController.*`;
  * `model/HexSphereModel.*`;
  * `generation/*` — генераторы рельефа и мешей.

* **Внешний вид (цвета, шейдеры, стили линий, вода)**

  * `renderers/HexSphereRenderer.*` и под-рендереры;
  * шейдеры и ресурсы в `resources/`.

* **Объекты на планете (юниты, маркеры, башни и др.)**

  * `ECS/` — компоненты и хранение;
  * создание и управление сущностями — в `InputController::initialize` и связанных методах.

* **Панель настроек и связи между UI и логикой**

  * `ui/PlanetSettingsPanel.*` — виджет панели;
  * `ui/MainWindow.*` — соединение сигналов панели с методами `HexSphereWidget` / `InputController`.

Если вы знаете, какой аспект поведения нужно изменить (ввод, камера, логика планеты, рендер или сущности), по этой схеме можно быстро найти соответствующий участок кода.

---

### 12. Схемы потоков

#### 12.1. Общий поток событий

```text
События Qt (мышь, клавиатура, resize)
   ↓
HexSphereWidget (QOpenGLWidget)
   ↓
InputController (логика ввода и сцены)
   ↓
HexSphereSceneController (логика планеты) / ECS (юниты и объекты) / Model (сырые данные) 
   ↓
HexSphereRenderer → OpenGL → GPU (шейдеры)
```

#### 12.2. Поток от панели настроек

```text
PlanetSettingsPanel (UI)
   ↓ (signals)
MainWindow
   ↓ (slots / вызовы методов)
HexSphereWidget / InputController
   ↓
HexSphereSceneController (логика планеты) / Model (данные планеты) / Renderer
```

---

### 13. Соглашения по стилю проекта

* Все операции, изменяющие планету, проходят через `HexSphereSceneController` (а не напрямую через `HexSphereModel`).
* Любой новый компонент ECS располагается в папке `ECS/` и учитывается в `ComponentStorage`.
* Ни один под-рендерер не должен менять состояние `HexSphereSceneController` или `ECS::ComponentStorage`.
* Генераторы рельефа реализуют общий интерфейс и подключаются через `HexSphereSceneController`.
* Расширения интерфейса рендера делаются через структуры данных (`RenderGraph`, `SceneLighting`, `UploadOptions`), а не прямыми вызовами OpenGL из контроллеров.

---

### 14. Как устроен picking (выбор объектов)

Picking (выбор ячеек и сущностей под курсором) разбит на несколько шагов:

1. В `InputController::mousePress` берётся позиция курсора и вызывается `pickSceneAt(sx, sy)`.
2. `pickSceneAt` строит луч из камеры:

   * через `camera_.rayDirectionFromScreen(sx, sy, width, height, devicePixelRatioF())`.
3. `pickEntityAt` проверяет пересечение луча со сферическими коллайдерами сущностей (`ecs::Collider` + `ecs::Transform`).
4. `pickTerrainAt` проверяет пересечение луча с треугольниками поверхности планеты:

   * данные треугольников берутся из `scene_.terrain().pos`, `idx`, `triOwner`.
5. Функция выбирает ближайшее попадание по параметру `t` вдоль луча и возвращает `PickHit`.
6. В зависимости от результата:

   * при попадании в сущность — вызывается `selectEntity`;
   * при попадании в ячейку — обновляется выделение в `HexSphereSceneController` и двигается выбранная сущность.

---

### 15. Шейдеры, ресурсы и связь с `TerrainMesh`

* Все шейдеры и связанные ресурсы собираются через Qt-ресурсный файл `resources/Planet.qrc`.
* Тексты шейдеров могут быть инкапсулированы в сгенерированном заголовке (например, `HexSphereWidget_shaders.h`).

Основные типы шейдерных программ:

* **террейн (terrain)** — отображают рельеф и биомы поверхности планеты;
* **вода (water)** — добавляют анимацию и визуальные эффекты поверхности воды;
* **сущности (entities)** — рисуют объекты из ECS;
* **оверлей (overlay)** — рисуют контуры выделения, путь и вспомогательную графику.

#### 15.1. Какие атрибуты ждёт шейдер террейна

Рендерер террейна напрямую использует данные из `TerrainMesh` (см. разд. 21.2):

```cpp
struct TerrainMesh {
    std::vector<float>    pos;   // позиция: vec3
    std::vector<float>    col;   // цвет: vec3
    std::vector<float>    norm;  // нормаль: vec3
    std::vector<uint32_t> idx;   // индексы треугольников
    std::vector<int>      triOwner;
};
```

Типичный layout атрибутов в GLSL-шейдере террейна:

```glsl
layout(location = 0) in vec3 a_position;  // из TerrainMesh::pos
layout(location = 1) in vec3 a_normal;    // из TerrainMesh::norm
layout(location = 2) in vec3 a_color;     // из TerrainMesh::col
```

Соответствие задаётся в `TerrainRenderer`: он привязывает VBO с позициями, нормалями и цветами к нужным `location`, а затем вызывает отрисовку по индексам `idx`.

Шейдеры воды и оверлея используют схожую схему:

* вода берёт позиции из `WaterGeometryData::positions` и флаги границ из `edgeFlags` (например, для подсветки береговой линии);
* оверлей берёт линии контура выделения и путь как `vec3`-позиции, рисуя их отдельными примитивами поверх террейна;
* шейдер сущностей читает атрибуты мешей, назначенных в ECS (`ecs::Mesh::meshId`) и преобразованных в GPU-буферы в `EntityRenderer`.

#### 15.2. Как найти и изменить шейдеры

* Шейдерные тексты лежат в `resources/` (файлы `.glsl`, `.vert`, `.frag`) и подключаются через Qt Resource System.
* Связь между C++ и шейдерами осуществляется через идентификаторы программ и uniform-переменные, которые настраиваются в коде рендерера (`HexSphereRenderer` и под-рендереры).

Для изменения визуального стиля:

1. Найдите соответствующий шейдер в `resources/`.
2. Измените код шейдера (цвета, освещение, туман, модель воды и т.п.).
3. При необходимости обновите привязку uniform-параметров в рендерере.
4. Пересоберите проект, чтобы Qt заново упаковал ресурсы.

---

### 16. Минимальный пример: создание новой сущности

Пример кода создания сущности с позицией, мешом и коллайдером (упрощённо):

```cpp
auto& e = ecs_.createEntity("MyUnit");

// Положение в мире
auto& transform = ecs_.emplace<ecs::Transform>(e.id);
transform.position = QVector3D(0.0f, 0.0f, 1.0f);

// Какой меш рисовать (идентификатор задаётся на стороне рендерера)
auto& mesh = ecs_.emplace<ecs::Mesh>(e.id);
mesh.meshId = "pyramid";

// Коллайдер для пика/столкновений
auto& collider = ecs_.emplace<ecs::Collider>(e.id);
collider.radius = 0.05f;
```

После этого, если `EntityRenderer` настроен на отрисовку сущностей с такими компонентами, новый объект появится на планете.

---

### 17. Текущие сущности в проекте

По умолчанию при инициализации сцены `InputController` создаёт базовую сущность-"исследователь" (`"Explorer"`):

* сущность с именем `"Explorer"`;
* компонент `Transform` с позицией на поверхности планеты (в одной из ячеек);
* компонент `Mesh` с идентификатором меша (например, `"pyramid"` для небольшой пирамиды);
* компонент `Collider` с радиусом, используемым для пика и потенциальных столкновений.

Дополнительные сущности можно создавать по аналогии с этим примером, навешивая на них нужные компоненты ECS.

---

### 18. Словарь ключевых терминов

* **RenderGraph** — структура с данными сцены для конкретного кадра (геометрия, параметры террейна и т.п.).
* **RenderCamera** — положение и матрицы камеры, передаваемые в рендерер.
* **SceneLighting** — параметры освещения и времени воды, которые используются в шейдерах.
* **UploadOptions** — стратегия загрузки буферов (STATIC/DYNAMIC, использование статических/динамических VBO).
* **Subdivision Level (L)** — глубина разбиения икосферы, влияет на число ячеек.
* **Cell** — ячейка на поверхности планеты (узел `HexSphereModel`).
* **Entity (сущность)** — объект в ECS, идентификатор + набор компонентов.
* **Component (компонент)** — простая структура данных, описывающая аспект сущности (позиция, коллайдер, меш и т.п.).

---

### 19. Обзор папок проекта

Краткая шпаргалка по основным директориям:

* `ui/`          — Qt UI (окна, панели, OpenGL-виджет, обработка Qt-событий).
* `controllers/` — логика ввода, камеры, сцены, связь между UI, моделью и рендером.
* `model/`       — данные икосферы (ячейки, соседи, высоты, биомы).
* `generation/`  — генераторы рельефа и генераторы мешей.
* `renderers/`   — OpenGL-рендерер и под-рендереры.
* `ECS/`         — сущности и компоненты.
* `scene/`       — вспомогательные структуры сцены и геометрии.
* `resources/`   — шейдеры и другие ресурсы (через Qt Resource System).
* `docs/`        — архитектурные заметки и планы рефакторинга.
* `tools/`       — утилиты для отладки и генерации данных.
* `tests/`       — тестовые и демонстрационные сцены.

---

### 20. С чего начать чтение кода новичку

Рекомендуемый путь для первого знакомства с проектом:

1. Разделы **0–5** этого README — чтобы понять общую картину.
2. `ui/HexSphereWidget.*` — как Qt вызывает отрисовку и передаёт события.
3. `controllers/InputController.*` — главный «мозг» проекта: ввод, сцена, рендер.
4. `controllers/HexSphereSceneController.*` + `model/HexSphereModel.*` — как устроена планета и её данные.
5. `renderers/HexSphereRenderer.*` — как данные превращаются в картинку.
6. `ECS/` — как устроены сущности и компоненты.

После этого можно возвращаться к этому README как к карте и использовать специализированные разделы (10–20) для конкретных задач.

Отдельно остаются за рамками этого документа более узкие технические детали: математика генерации рельефа, специфические формулы шейдеров, тонкости работы OpenGL-пайплайна, внутренние алгоритмы генерации мешей и оптимизации буферов. Здесь описана прежде всего архитектура и потоки данных; за реализацией низкоуровневых алгоритмов имеет смысл обращаться непосредственно к исходному коду соответствующих модулей.

## 21. API-справочник по основным структурам

Этот раздел предназначен для тех случаев, когда нужно понять, **какие именно поля есть у основных структур данных** и **какие инварианты они соблюдают**. Здесь собраны только самые важные типы, с которыми вы столкнётесь при доработке логики и рендера.

### 21.1. `HexSphereModel` и `Cell`

**Где искать:** `model/HexSphereModel.*`.

#### 21.1.1. Структура `Cell`

Упрощённо (без служебных деталей):

```cpp
struct Cell {
    int id;                    // совпадает с индексом вершины исходной икосферы
    bool isPentagon;           // true, если степень 5, иначе 6
    std::vector<int> poly;     // индексы в dualVerts, обход CCW вокруг ячейки
    std::vector<int> neighbors;// id соседних ячеек, CCW, длина == poly.size()
    int height;                // дискретная высота (целое значение)
    Biome biome;               // тип биома
    QVector3D centroid;        // нормализованный центроид (мировые координаты)
    float area;                // площадь (для информации)
    uint32_t stateMask;        // бит 0 — выделена ли ячейка
};
```

Основные инварианты:

* `poly.size() == neighbors.size()` — у каждой стороны есть сосед.
* `poly` хранит индексы в `dualVerts` (`HexSphereModel::dualVerts()`), а не в массив `cells`.
* `centroid` всегда нормализован и лежит на единичной сфере.
* `height` — целое число, реальная высота получается умножением на `heightStep`.
* `stateMask & 1u` используется для логического выделения (selection).

#### 21.1.2. Класс `HexSphereModel`

Ключевые поля и методы (в концептуальном виде):

* Геометрия и топология:

  * `const std::vector<QVector3D>& dualVerts() const;` — вершины дуального графа (по одной на треугольник исходной икосферы).
  * `const std::vector<Cell>& cells() const;` / `std::vector<Cell>& cells();` — массив ячеек.
  * `const std::vector<std::pair<int,int>>& wireEdges() const;` — уникальные рёбра дуального графа (пары индексов в `dualVerts`).
  * `const std::vector<PickTri>& pickTris() const;` — треугольники для ray picking (см. раздел 14).
* Размерность и статистика:

  * `int subdivisions() const;` — уровень разбиения L.
  * `int pentagonCount() const;` — число пятиугольных ячеек.
  * `int cellCount() const;` — число ячеек.
* Удобные изменяющие методы:

  * `setHeight(int cellId, int h);`
  * `addHeight(int cellId, int dh);`
  * `setBiome(int cellId, Biome b);`

Инварианты модели:

* `dualVerts().size()` совпадает с числом треугольников исходной икосферы.
* `cells().size()` совпадает с числом вершин икосферы (одна ячейка на одну вершину).
* `wireEdges()` всегда содержит неориентированные рёбра без дубликатов.
* `pickTris()` покрывает всю поверхность планеты без самопересечений и используется только для пика и вспомогательной визуализации.

`HexSphereSceneController` никогда не меняет внутреннюю топологию `HexSphereModel`, он только обновляет высоты/биомы и пересчитывает производные меши (terrain, water и т.п.).

---

### 21.2. Геометрия террейна и воды: `TerrainMesh`, `WaterGeometryData`

#### 21.2.1. `TerrainMesh`

**Где искать:** `renderers/TerrainTessellator.h`.

```cpp
struct TerrainMesh {
    std::vector<float>    pos;   // xyz, по 3 float на вершину
    std::vector<float>    col;   // rgb, по 3 float на вершину
    std::vector<float>    norm;  // nx, ny, nz, по 3 float на вершину
    std::vector<uint32_t> idx;   // индексы треугольников
    std::vector<int>      triOwner; // для каждого треугольника — id ячейки
};
```

Инварианты:

* `pos.size() % 3 == 0`, `col.size() % 3 == 0`, `norm.size() % 3 == 0` — каждые 3 числа образуют один вектор.
* `idx.size() % 3 == 0` — индексы хранятся тройками (по одному треугольнику).
* `triOwner.size() == idx.size() / 3` — для каждого треугольника есть ровно один владелец-ячейка.
* Все координаты в `pos` заданы в мировых координатах и лежат на сфере радиуса `R + height * heightStep`.

`TerrainMesh` строится в `TerrainTessellator::build(const HexSphereModel&)`, а сам тесселлятор вызывается через `TerrainMeshGenerator` из `HexSphereSceneController::updateTerrainMesh()`. После этого `InputController::uploadBuffers()` передаёт `terrainCPU_` в `HexSphereRenderer::uploadScene(...)`.

#### 21.2.2. `WaterGeometryData`

**Где искать:** `generation/MeshGenerators/WaterMeshGenerator.h`.

```cpp
struct WaterGeometryData {
    std::vector<float>    positions; // xyz для вершин воды
    std::vector<float>    edgeFlags; // 1.0 на границах, 0.0 внутри (для шейдера)
    std::vector<uint32_t> indices;   // треугольники воды
};
```

Инварианты:

* `positions.size() % 3 == 0`.
* `edgeFlags.size() == positions.size() / 3` — по одному флагу на вершину.
* `indices.size() % 3 == 0`.
* Все вершины лежат примерно на фиксированном радиусе «уровня моря» (например, 1.0).

`WaterGeometryData` заполняется в `WaterMeshGenerator::buildWaterGeometry(const HexSphereModel&)` и попадает в рендер через `HexSphereRenderer::uploadWater(...)` и далее в `WaterRenderer`.

---

### 21.3. Контракт между сценой и рендерером: `RenderGraph`, `RenderCamera`, `SceneLighting`, `RenderContext`

**Где искать:** `renderers/HexSphereRenderer.h`.

#### 21.3.1. `RenderGraph`

```cpp
struct RenderGraph {
    const HexSphereSceneController& scene;
    const ecs::ComponentStorage&    ecs;
    float                           heightStep;
};
```

Смысл полей:

* `scene` — текущее состояние планеты и её CPU-меши (terrain, water, wire, selection outline, путь).
* `ecs` — все сущности и компоненты (юниты, маркеры и т.п.).
* `heightStep` — шаг по высоте, согласованный с `scene.heightStep()`.

`RenderGraph` заполняется в `InputController::render()` с использованием текущего `scene_`, `ecs_` и `scene_.heightStep()`.

#### 21.3.2. `RenderCamera`

```cpp
struct RenderCamera {
    QMatrix4x4 view;
    QMatrix4x4 projection;
};
```

* `view` — матрица вида из `CameraController`.
* `projection` — перспектива/ортогональная проекция, также задаётся `CameraController` и обновляется при `resize`.

#### 21.3.3. `SceneLighting`

```cpp
struct SceneLighting {
    QVector3D direction;  // направление света в мировых координатах
    float     waterTime;  // «время» для анимации воды
};
```

* `direction` — нормализованный вектор направления света (например, от солнца).
* `waterTime` — накопленное время, которое увеличивается в `InputController::advanceWaterTime(dt)` и используется в water-шейдере для анимации волн.

#### 21.3.4. `RenderContext`

```cpp
struct RenderContext {
    const RenderGraph&    graph;
    const RenderCamera&   camera;
    const SceneLighting&  lighting;
    QMatrix4x4            mvp;       // projection * view
    QVector3D             cameraPos; // позиция камеры в мировых координатах
};
```

* `mvp` вычисляется в `HexSphereRenderer::renderScene(...)` как `camera.projection * camera.view`.
* `cameraPos` вычисляется через обратную матрицу вида.
* `RenderContext` передаётся во все под-рендереры (terrain, water, entities, overlay), которые **только читают** данные и не меняют `graph`.

Для наглядности контракт можно свести к таблице:

| Кому рендерер рисует                  | Что он ожидает получить от `RenderGraph` / сцены                          |
| ------------------------------------- | ------------------------------------------------------------------------- |
| TerrainRenderer (поверхность планеты) | `scene.terrain()` (`TerrainMesh`: `pos`, `norm`, `col`, `idx`)            |
| WaterRenderer (вода)                  | `scene.buildWaterGeometry()` (`WaterGeometryData`) и `lighting.waterTime` |
| EntityRenderer (юниты, маркеры)       | ECS-сущности с компонентами `Transform` + `Mesh`                          |
| OverlayRenderer (контуры, путь)       | вершины контура выделения и полилиний пути из `HexSphereSceneController`  |

Задача `HexSphereSceneController` и ECS — заполнить эти структуры и компоненты. Задача `HexSphereRenderer` и под-рендереров — прочитать их и корректно нарисовать, не изменяя состояние сцены.

---

### 21.4. Координатные системы и высоты

Основные соглашения по координатам:

* Центр планеты находится в начале координат (0,0,0).
* Все базовые вершины (`dualVerts`, `centroid` в `Cell`) лежат на **единичной сфере**.
* Физическая высота задаётся как:

  ```text
  radius = R + height * heightStep
  ```

  где `R` — базовый радиус (обычно 1.0), `height` — целое из `Cell::height`, `heightStep` — вещественный шаг высоты.
* Позиции сущностей (`ecs::Transform::position`) задаются сразу в мировых координатах и, как правило, равны положению точки на сфере (возможно, с небольшим смещением наружу).

При генерации мешей террейна и контура выделения используются различные комбинации:

* подъём точки над сферой на `height * heightStep`;
* дополнительный bias (`outlineBias`, `stripInset` и т.п.) для визуального отделения линий и полос.

Главное: **все структуры, которые передаются в рендерер (`TerrainMesh`, `WaterGeometryData`, пути, контуры)** уже находятся в единой мировой системе координат.

---

### 21.5. Триангуляция террейна и picking

Этот подпункт дополняет раздел 14 «Как устроен picking» более формальными деталями.

#### 21.5.1. `triOwner[]` в `TerrainMesh`

При построении меша террейна `TerrainTessellator` заполняет массив `triOwner` через внутренний `MeshBuilder`:

* при добавлении треугольника или квадрата каждый элемент (треугольник) получает `cellOwner` — id ячейки `Cell`;
* `triOwner[k]` соответствует тройке индексов `idx[3*k + 0..2]`.

Это гарантирует однозначное соответствие «треугольник → ячейка». Это соответствие используется, например, для более сложных схем подсветки, вычисления нормалей на основе высот клеток и потенциально может быть использовано для advanced picking.

#### 21.5.2. `PickTri` в `HexSphereModel`

Помимо `TerrainMesh`, для быстрого picking используется отдельная структура:

```cpp
struct PickTri {
    int        cellId;  // к какой ячейке относится треугольник
    QVector3D  v0, v1, v2; // вершины треугольника в мировых координатах
};
```

Массив `pickTris_` заполняется в `HexSphereModel::rebuildFromIcosphere(...)` следующим образом:

* для каждой ячейки строится веер треугольников от центроида ячейки к вершинам её многоугольника (`poly` → `dualVerts`);
* каждый такой треугольник получает соответствующий `cellId`.

`InputController::pickCellAt` проходит по этому массиву и проверяет пересечение луча от камеры с каждым треугольником, выбирая ближайшее попадание.

Таким образом:

* `triOwner[]` в `TerrainMesh` привязан к визуальному мешу террейна;
* `PickTri[]` в `HexSphereModel` — специализированный, более геометрически простой меш, оптимизированный для picking.

Обе структуры согласованы через `cellId`, но имеют разное назначение и разную геометрию.

---

### 21.6. PathBuilder: построение пути по ячейкам

**Где искать:** `controllers/PathBuilder.*`, вызовы — в `HexSphereSceneController::buildPathPolyline()`.

PathBuilder отвечает за построение пути по центрам ячеек планеты:

1. `HexSphereSceneController::buildPathPolyline()` проверяет, что выделено ровно две ячейки (точка A и точка B).
2. Локально создаётся `PathBuilder pb(model_)`.
3. Вызов `pb.build()` строит неориентированный граф по соседям ячеек (`Cell::neighbors`).
4. Вызов `pb.astar(a, b)` выполняет A* по этому графу:

   * вершины графа — id ячеек;
   * вес ребра по умолчанию равен 1 (можно изменить через `WeightFn`);
   * эвристика — дуговое расстояние по сфере между центроидами ячеек.
5. Полученный путь `std::vector<int>` (последовательность id ячеек) передаётся в `pb.polylineOnSphere(...)`, где:

   * каждая пара соседних ячеек интерполируется по дуге большой окружности (slerp);
   * высота вдоль ребра лерпуeтся по высотам ячеек и преобразуется в радиус `R + height * heightStep + bias`.
6. На выходе получается массив `QVector3D` в мировых координатах, который `HexSphereRenderer` рисует как линию пути.

Важные свойства:

* `PathBuilder` не хранит глобальное состояние и создаётся по мере необходимости.
* Геометрия пути полностью определяется текущим `HexSphereModel` (топология ячеек и их высоты).
* Для изменения логики пути (стоимость ребра, форма полилинии, количество сегментов) достаточно модифицировать `PathBuilder` и/или `buildPathPolyline()`.
