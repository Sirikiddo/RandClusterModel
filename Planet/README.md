## Архитектура проекта Planet (как ориентироваться в коде)

Проект организован так, чтобы новый функционал можно было быстро найти, понять и доработать. Ниже описано, какие есть слои, какие у них роли и куда смотреть для любой фичи.

---

### 1. Архитектурные принципы

Чтобы код оставался понятным и расширяемым, проект придерживается простых правил:

* UI (`ui/`) **не содержит игровой логики**. Виджеты принимают события и вызывают контроллеры.
* Контроллеры (`controllers/`) **ничего не рисуют сами** и почти не зависят от Qt кроме указателя на виджет.
* Модель и генерация (`model/`, `generation/`) — **чистый C++ без Qt и OpenGL**: структуры данных и функции.
* Рендереры (`renderers/`) работают только с:

  * данными от контроллеров,
  * OpenGL и шейдерами,
  * и **не меняют** игровое состояние.
* ECS (`ECS/`) хранит сущности и компоненты, но **не знает**, как их рисуют и кто им управляет.

Если при добавлении фичи эти правила нарушаются — архитектуру стоит пересмотреть.

---

### 2. Общий поток работы

1. **Запуск приложения**

   * Файл: `core/main.cpp`
   * Создаётся `QApplication`, настраивается формат OpenGL, создаётся и показывается `MainWindow`.

2. **Главное окно и панель настроек**

   * Файлы: `ui/MainWindow.*`, `ui/PlanetSettingsPanel.*`
   * `MainWindow`:

     * создаёт центральный OpenGL-виджет `HexSphereWidget`;
     * создаёт панель настроек (`PlanetSettingsPanel`) в доке;
     * соединяет сигналы панели (изменение генератора, параметров рельефа и т.п.) с методами центрального виджета.

3. **OpenGL-виджет планеты**

   * Файлы: `ui/HexSphereWidget.*`
   * Наследник `QOpenGLWidget`, отвечает за:

     * инициализацию контекста (`initializeGL`);
     * реакцию на изменение размера (`resizeGL`);
     * отрисовку кадра (`paintGL`);
     * приём Qt-событий (`mouse*`, `key*`, `wheel`) и передачу их в контроллер.
   * Внутри хранит:

     * `CameraController` — управление камерой;
     * `InputController` — логика ввода, сцены и рендера.

---

### 3. Слои и модули

#### 3.1. Контроллер ввода и сцены

* Файлы: `controllers/InputController.*`
* Центральное место, где сходится всё:

  * инициализирует `HexSphereRenderer` и OpenGL-функции;
  * создаёт начальные сущности (например, «исследователь» на поверхности);
  * хранит:

    * `HexSphereSceneController` — состояние планеты и её меши;
    * `ecs::ComponentStorage` — сущности и компоненты (позиция, коллайдеры, меши);
    * `PerformanceStats` — статистика рендеринга;
    * настройки загрузки буферов.
* Обрабатывает ввод:

  * клики мышью, перемещение, колесо, клавиши;
  * вычисляет луч от камеры под курсором;
  * выбирает ячейки планеты и сущности;
  * меняет высоту, биомы, выделение, путь;
  * двигает выбранную сущность по поверхности.
* Управляет перестройкой сцены:

  * `rebuildModel()` — пересобирает модель планеты;
  * `uploadBuffers()` — отправляет данные на GPU;
  * `render()` — собирает `RenderGraph`, `RenderCamera`, `SceneLighting` и вызывает `HexSphereRenderer`.

#### 3.2. Камера

* Файлы: `controllers/CameraController.*`
* Отвечает за:

  * положение и ориентацию камеры;
  * матрицы `view` и `projection`;
  * вращение (`rotate`), зум (`zoom`), сброс (`reset`);
  * вычисление направления луча по экранным координатам (`rayDirectionFromScreen`).

#### 3.3. Контроллер планеты

* Файлы: `controllers/HexSphereSceneController.*`
* Отвечает за:

  * уровень разбиения (subdivision level);
  * модель планеты (`HexSphereModel`);
  * параметры генерации рельефа и биомов;
  * CPU-меши террейна, воды, контура выделения, пути;
  * список выделенных ячеек.
* Предоставляет методы:

  * смена генератора рельефа;
  * перерасчёт рельефа;
  * построение полигона пути по выделенным ячейкам;
  * построение данных для рендера (позиции, индексы, владельцы треугольников и т.п.).

#### 3.4. Модель планеты и генерация рельефа

* Папка: `model/`

  * `HexSphereModel` — данные ячеек (центры, соседи, высоты, биомы).
* Папка: `generation/`

  * интерфейс генераторов рельефа;
  * конкретные генераторы (плоский, синус, Перлин, климатический и др.);
  * генераторы мешей террейна, воды, wire-каркаса, контура выделения.

#### 3.5. Рендеринг

* Папка: `renderers/`
* `HexSphereRenderer`:

  * владеет шейдерами и OpenGL-буферами;
  * имеет методы:

    * `initialize(...)` — создание ресурсов;
    * `uploadScene(...)` — загрузка планеты;
    * `uploadSelectionOutline(...)` — контур выделения;
    * `uploadPath(...)` — путь по поверхности;
    * `renderScene(...)` — отрисовка кадра.
* Под-рендереры (terrain, water, entities, overlay) рисуют соответствующие части сцены.

#### 3.6. ECS (сущности и компоненты)

* Папка: `ECS/`
* `ComponentStorage` — хранение сущностей и наборов компонентов:

  * `Transform` — позиция в мире;
  * `Mesh` — какой меш рисовать;
  * `Collider` — сфера для пика/столкновений;
  * другие компоненты по мере необходимости.
* `InputController` создаёт сущности и управляет их жизненным циклом.
* Рендерер рисует сущности, у которых есть нужные компоненты.

#### 3.7. Сцена и геометрия

* Папка: `scene/`
* Вспомогательные структуры сцены:

  * узлы сцены, связи, дополнительные данные для навигации и визуализации.
* Используется вместе с `HexSphereModel` и `ECS`:

  * планета и её поверхность — в `model/` и `scene/`;
  * отдельные объекты на планете — в `ECS/`.

#### 3.8. Ресурсы, документация, инструменты

* `resources/`:

  * `Planet.qrc` — Qt-ресурсный файл;
  * шейдеры и другие данные, используемые рендерером.
* `docs/`:

  * заметки по архитектуре и плану рефакторинга (например, `planet_reorg_tasks.md`).
* `tools/`:

  * вспомогательные утилиты для отладки и генерации данных.
* `tests/`:

  * тесты и экспериментальные сцены (можно использовать как минимальные примеры).

---

### 4. Пример: что происходит при клике мышью по ячейке

1. Qt вызывает `HexSphereWidget::mousePressEvent(QMouseEvent* e)`.
2. `HexSphereWidget` передаёт событие в контроллер:

   ```cpp
   auto response = inputController_->mousePress(e);
   ```
3. В `InputController::mousePress`:

   * берётся позиция курсора `e->position()`;
   * вызывается `pickSceneAt(...)`, чтобы понять, в какую ячейку или сущность попал луч;
   * если попали в ячейку:

     * обновляется выделение в `HexSphereSceneController` (`scene_.toggleCellSelection(...)`);
     * по возможности двигается выбранная сущность в эту ячейку (через ECS);
     * вызываются `uploadSelection()` / `rebuildModel()` при необходимости;
     * ставится флаг `response.requestUpdate = true`.
4. `HexSphereWidget` по флагу вызывает `update()`.
5. Qt вызывает `paintGL()`, который вызывает `InputController::render()`.
6. В `render()`:

   * собирается `RenderGraph`, `RenderCamera`, `SceneLighting`;
   * вызывается `renderer_->renderScene(...)`;
   * на экране видна новая конфигурация планеты и объектов.

---

### 5. Цикл обновления и анимация

* В `HexSphereWidget` настроен таймер, который периодически:

  * вызывает `InputController::advanceWaterTime(dt)`;
  * вызывает `update()`, чтобы перерисовать сцену.
* В `InputController::render()` текущее время воды и параметры освещения передаются в `SceneLighting` и шейдеры через `HexSphereRenderer`.
* `PerformanceStats` обновляет FPS и другие метрики, которые могут выводиться в HUD.

Это и есть простой «игровой цикл» проекта.

---

### 6. Где искать код для изменений

Для любой новой фичи можно пользоваться следующей картой:

* **Поведение при клике, движении мыши, нажатии клавиш**

  * `ui/HexSphereWidget.*` — вход Qt-событий;
  * `controllers/InputController.*` — логика реакции и изменения состояния.

* **Управление камерой (вращение, зум, FOV, луч под курсор)**

  * `controllers/CameraController.*`.

* **Логика планеты (сеточка, высоты, биомы, выделение, путь)**

  * `controllers/HexSphereSceneController.*`;
  * `model/HexSphereModel.*`;
  * `generation/*` — генераторы рельефа и мешей.

* **Внешний вид (цвета, шейдеры, стили линий, вода)**

  * `renderers/HexSphereRenderer.*` и под-рендереры;
  * шейдеры и ресурсы в `resources/`.

* **Объекты на планете (юниты, маркеры, башни и др.)**

  * `ECS/` — компоненты и хранение;
  * создание и управление сущностями — в `InputController::initialize` и связанных методах.

* **Панель настроек и связи между UI и логикой**

  * `ui/PlanetSettingsPanel.*` — виджет панели;
  * `ui/MainWindow.*` — соединение сигналов панели с методами `HexSphereWidget` / `InputController`.
